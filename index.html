<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
        <title>D3 Census Map</title>  
        <script src="http://d3js.org/d3.v4.min.js" charset="utf-8"></script> 
        <!-- <script src="https://unpkg.com/topojson@3"></script> -->
        <script src="http://d3js.org/topojson.v1.min.js"></script>
        <script src="http://d3js.org/queue.v1.min.js"></script>
        <!-- <script src="http://code.jquery.com/jquery-latest.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/0.8.3/jquery.csv.min.js"></script> -->
        <!-- <script src="App.js"></script> -->
        <style>
            svg {
                background: white;
            }
            path {
                fill: #cccccc;
                stroke: #333333;
                stroke-width: 0.5;
            }
        </style>
    </head> 
    <body>
      <h1>US Blocks</h1>
      <div id="map"></div>
      <script>
        var width = 1024,
        height = 800;
        
        var svg = d3.select("body")
                .append("svg")
                .attr("width", width)
                .attr("height", height);    

        // testing with smaller county json file
        d3.json("tl_2020_us_county.json", function(error, us) {
        // d3.json("tl_2020_25MA_tabblock20.json", function(error, us) {
            if (error) return console.error(error);
            // subunits is all county/block boundaries
            var subunits = topojson.feature(us, us.objects.tl_2020_us_county).features;
            // var subunits = topojson.feature(us, us.objects.tl_2020_25_tabblock20).features;
            // choose which counties/blocks to display
            var tmpunits = [];
            for (let i = 0; i < subunits.length; i++) {
                if (subunits[i].properties["STATEFP"] == '25') {
                    tmpunits.push(subunits[i]);
                }
            }
            tmpunits.sort(function(s1, s2) {
                // right to left
                return parseFloat(s1.properties["INTPTLON"].slice(1)) - parseFloat(s2.properties["INTPTLON"].slice(1));
                // return parseFloat(s1.properties["INTPTLON20"].slice(1)) - parseFloat(s2.properties["INTPTLON20"].slice(1))
            });
            console.log("len", tmpunits.length);
            var projection = d3.geoAlbersUsa()
                .translate([width/2 - 2000, height/2 + 400])
                .scale(6000);
                //.translate([width/2-2000, height/2 + 300]) // +700 for CA
                //.scale(5000);  
            var map_coord = d3.geoPath()
                .projection(projection);
            svg.selectAll("path")
                .data(tmpunits)
                .enter()
                .append("path")
                .attr("d", map_coord); // map_coord same as: d => map_coord(d)

            console.log('rendered boundaries');


            // racial demographic data & dots for select counties
            let csvdemographics = [];
            let dots = [];
            function genDotCoord (d, maxx, maxy, minx, miny, c) {
                let coordx = Math.random() * (maxx - minx) + minx;
                let coordy = Math.random() * (maxy - miny) + miny;
                let count = 0;
                while (!d3.geoContains(d, [coordx, coordy]) && count < 50) {
                    // console.log('nay');
                    coordx = Math.random() * (maxx - minx) + minx;
                    coordy = Math.random() * (maxy - miny) + miny;
                    ++count;
                }
                if (count == 50) {
                    console.log("Out of bounds");
                    return false;
                }
                let color = c;
                // console.log('yay');
                return [coordx, coordy, color];
            };

            let load = function(error, data) {
                // TODO: handle error case 
                if (error) return console.warn(error);
                // filtering demographic data for now for select counties
                for (var i = 0; i < data.length; i++) {
                    if (data[i]["STATE"] == "Massachusetts") {
                        csvdemographics.push(data[i]);
                    }                     
                }
                csvdemographics.sort(function(s1, s2) {
                    // right to left
                    return parseFloat(s1["INTPTLON"].slice(1)) - parseFloat(s2["INTPTLON"].slice(1));
                    // return parseFloat(s1.properties["INTPTLON20"].slice(1)) - parseFloat(s2.properties["INTPTLON20"].slice(1))
                });
                console.log("len2", csvdemographics.length);
                // change tmpunits later to subunits
                for (let i = 0; i < tmpunits.length; i++) {
                    // county is used to get coordinates
                    let county = tmpunits[i];                  
                    console.log("index", i);
                    console.log(county.geometry.coordinates["0"]);
                    let maxx = Math.max(...county.geometry.coordinates["0"].map(o => o[0]));
                    let maxy = Math.max(...county.geometry.coordinates["0"].map(o => o[1]));
                    let minx = Math.min(...county.geometry.coordinates["0"].map(o => o[0]));
                    let miny = Math.min(...county.geometry.coordinates["0"].map(o => o[1]));
                    if (!maxx) {
                        maxx = Math.max(...county.geometry.coordinates["0"][0].map(o => o[0]));
                        maxy = Math.max(...county.geometry.coordinates["0"][0].map(o => o[1]));
                        minx = Math.min(...county.geometry.coordinates["0"][0].map(o => o[0]));
                        miny = Math.min(...county.geometry.coordinates["0"][0].map(o => o[1]));
                    }
                    console.log(maxx, maxy, minx, miny);
                    // get corresponding racial demographic data
                    for (let j = 0; j < parseInt(csvdemographics[i]["U7B003"])/2000; j++) {
                        let color = "rgb(0, 0, 255)";
                        let coord = genDotCoord(county, maxx, maxy, minx, miny, color);
                        if (coord) dots.push(coord);
                    }
                    for (let j = 0; j < parseInt(csvdemographics[i]["U7B004"])/2000; j++) {
                        let color = "rgb(255, 255, 0)";
                        let coord = genDotCoord(county, maxx, maxy, minx, miny, color);
                        if (coord) dots.push(coord);
                    }
                }
                // plot dots
                svg.selectAll('circle')
                    .data(dots)
                    .enter()
                    .append('circle')
                    .style('fill', data => data[2])
                    .attr('r', 1)
                    .attr('transform', function(data) {return "translate(" + projection(data) + ")";});
            }

            d3.csv("county.csv", load);
           
            // give coord to get pixel
            // console.log(projection([-141.190,52.4739]));
            // pixel to coord
            // console.log(projection.invert([241.20395864818516, 649.6497666026178]));
        });   
        
       
        
    
      </script>
    </body>
</html>


    <!-- 
            var addPointsToMap = function(crimeData) {
                var colorScale  = d3.scale.category10();

                var radiusScale = d3.scale.sqrt()
                    .domain(d3.extent(crimeData, function(crime) { return +crime.TOT; }))
                    .range([2, 15]);

                // Add the tooltip container to the vis container
                // it's invisible and its position/contents are defined during mouseover
                var tooltip = d3.select("#map-container").append("div")
                    .attr("class", "tooltip")
                    .style("opacity", 0);

                // tooltip mouseover event handler
                var tipMouseover = function(d) {
                    this.setAttribute("class", "circle-hover"); // add hover class to emphasize

                    var color = colorScale(d.CR);
                    var html  = "<span style='color:" + color + ";'>" + d.CR + "</span><br/>" +
                                "Count: " + d.TOT + "<br/>Date: " + d.MO + "/" + d.YR;

                    tooltip.html(html)
                        .style("left", (d3.event.pageX + 15) + "px")
                        .style("top", (d3.event.pageY - 28) + "px")
                      .transition()
                        .duration(200) // ms
                        .style("opacity", .9) // started as 0!
                };

                // tooltip mouseout event handler
                var tipMouseout = function(d) {
                    this.classList.remove("circle-hover"); // remove hover class

                    tooltip.transition()
                        .duration(300) // ms
                        .style("opacity", 0); // don't care about position!
                };

                svg.selectAll("circle")
                    .data(crimeData)
                  .enter().append("circle")
                    .attr("fill", function(d) { return colorScale(d.CR); })
                    .attr("cx", function(d) { return projection([+d.longitude, +d.latitude])[0]; })
                    .attr("cy", function(d) { return projection([+d.longitude, +d.latitude])[1]; })
                    .attr("r",  function(d) { return radiusScale(+d.TOT); })
                    .on("mouseover", tipMouseover)
                    .on("mouseout", tipMouseout);

                addLegend(colorScale);
            };

            var addLegend = function(colorScale) {
                var legendMarginTop  = 50,
                    legendMarginLeft = 30,
                    legendWidth  = 250,
                    legendHeight = 150;

                var legend = svg.append('g')
                    .attr('width', legendWidth)
                    .attr('height', legendHeight)
                    .attr("transform", "translate(" + legendMarginLeft + "," + legendMarginTop + ")");

                var legends = legend.selectAll(".legend")
                    .data(colorScale.domain())
                  .enter().append("g")
                    .attr("class", "legend")
                    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

                // draw legend colored rectangles
                legends.append("rect")
                    .attr("x", legendWidth - 18)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", colorScale);

                // draw legend text
                legends.append("text")
                    .attr("x", legendWidth - 24)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "end")
                    .text(function(d) { return d.toLowerCase(); });
            };
